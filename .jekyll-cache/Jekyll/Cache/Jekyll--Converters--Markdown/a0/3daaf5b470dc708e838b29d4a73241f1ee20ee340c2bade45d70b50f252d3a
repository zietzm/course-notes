I"G<p>In the last chapter, we saw that inference in probabilistic models is often intractable, and we learned about algorithms that provide approximate solutions to the inference problem (e.g. marginal inference) by using subroutines that involve sampling random variables. Most sampling-based inference algorithms are instances of Markov Chain Monte-Carlo (MCMC); two popular MCMC methods are Gibbs sampling and Metropolis-Hastings.</p>

<p>Unfortunately, these sampling-based methods have several important shortcomings.</p>

<ul>
  <li>Although they are guaranteed to find a globally optimal solution given enough time, it is difficult to tell how close they are to a good solution given the finite amount of time that they have in practice.</li>
  <li>In order to quickly reach a good solution, MCMC methods require choosing an appropriate sampling technique (e.g. a good proposal in Metropolis-Hastings). Choosing this technique can be an art in itself.</li>
</ul>

<p>In this chapter, we are going to look at an alternative approach to approximate inference called the <em>variational</em> family of algorithms.</p>

<h2 id="inference-as-optimization">Inference as optimization</h2>

<p>The main idea of variational methods is to cast inference as an optimization problem.</p>

<p>Suppose we are given an intractable probability distribution <script type="math/tex">p</script>. Variational techniques will try to solve an optimization problem over a class of tractable distributions <script type="math/tex">\mathcal{Q}</script> in order to find a <script type="math/tex">q \in \mathcal{Q}</script> that is most similar to <script type="math/tex">p</script>. We will then query <script type="math/tex">q</script> (rather than <script type="math/tex">p</script>) in order to get an approximate solution.</p>

<p>The main differences between sampling and variational techniques are that:</p>

<ul>
  <li>Unlike sampling-based methods, variational approaches will almost never find the globally optimal solution.</li>
  <li>However, we will always know if they have converged. In some cases, we will even have bounds on their accuracy.</li>
  <li>In practice, variational inference methods often scale better and are more amenable to techniques like stochastic gradient optimization, parallelization over multiple processors, and acceleration using GPUs.</li>
</ul>

<p>Although sampling methods were historically invented first (in the 1940s), variational techniques have been steadily gaining popularity and are currently the more widely used inference technique.</p>

<h2 id="the-kullback-leibler-divergence">The Kullback-Leibler divergence</h2>

<p>To formulate inference as an optimization problem, we need to choose an approximating family <script type="math/tex">\mathcal{Q}</script> and an optimization objective <script type="math/tex">J(q)</script>. This objective needs to capture the similarity between <script type="math/tex">q</script> and <script type="math/tex">p</script>; the field of information theory provides us with a tool for this called the <em>Kullback-Leibler (KL) divergence</em>.</p>

<p>Formally, the KL divergence between two distributions <script type="math/tex">q</script> and <script type="math/tex">p</script> with discrete support is defined as</p>

<script type="math/tex; mode=display">KL(q\|p) = \sum_x q(x) \log \frac{q(x)}{p(x)}.</script>

<p>In information theory, this function is used to measure differences in information contained within two distributions. The KL divergence has the following properties that make it especially useful in our setting:</p>

<ul>
  <li><script type="math/tex">KL(q\|p) \geq 0</script> for all <script type="math/tex">q,p</script>.</li>
  <li><script type="math/tex">KL(q\|p) = 0</script> if and only if <script type="math/tex">q = p</script>.</li>
</ul>

<p>These can be proven as an exercise. Note however that <script type="math/tex">KL(q\|p) \neq KL(p\|q)</script>, i.e. the KL divergence is not symmetric. This is why we say that it’s a divergence, but not a distance. We will come back to this distinction shortly.</p>

<h2 id="the-variational-lower-bound">The variational lower bound</h2>

<p>How do we perform variational inference with a KL divergence? First, let’s fix a form for <script type="math/tex">p</script>. We’ll assume that <script type="math/tex">p</script> is a general (discrete, for simplicity) undirected model of the form</p>

<script type="math/tex; mode=display">p(x_1,\ldots,x_n; \theta) = \frac{\tp(x_1,\ldots,x_n ; \theta)}{Z(\theta)} =\frac{1}{Z(\theta)} \prod_{k} \phi_k(x_k; \theta),</script>

<p>where the <script type="math/tex">\phi_k</script> are the factors and <script type="math/tex">Z(\theta)</script> is the normalization constant. This formulation captures virtually all the distributions in which we might want to perform approximate inference, such as marginal distributions of directed models <script type="math/tex">p(x\mid e) = p(x,e)/p(e)</script> with evidence <script type="math/tex">e</script>.</p>

<p>Given this formulation, optimizing <script type="math/tex">KL(q\|p)</script> directly is not possible because of the potentially intractable normalization constant <script type="math/tex">Z(\theta)</script>. In fact, even evaluating <script type="math/tex">KL(q\|p)</script> is not possible, because we need to evaluate <script type="math/tex">p</script>.</p>

<p>Instead, we will work with the following objective, which has the same form as the KL divergence, but only involves the unnormalized probability <script type="math/tex">\tp(x) = \prod_{k} \phi_k(x_k; \theta)</script>:</p>

<script type="math/tex; mode=display">J(q) = \sum_x q(x) \log \frac{q(x)}{\tp(x)}.</script>

<p>This function is not only tractable, it also has the following important property:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
J(q)
&= \sum_x q(x) \log \frac{q(x)} {\tp(x)} \\
&= \sum_x q(x) \log \frac{q(x)}{p(x)} - \log Z(\theta) \\
&= KL(q\|p) - \log Z(\theta)
\end{align*} %]]></script>

<p>Since <script type="math/tex">KL(q\|p) \geq 0</script>, we get by rearranging terms that</p>

<script type="math/tex; mode=display">\log Z(\theta) = KL(q\|p) - J(q) \geq -J(q).</script>

<p>Thus, <script type="math/tex">-J(q)</script> is a <em>lower bound</em> on the log partition function <script type="math/tex">\log Z(\theta)</script>. In many cases, <script type="math/tex">Z(\theta)</script> has an interesting interpretation. For example, we may be trying to compute the marginal probability <script type="math/tex">p(x \mid D) = p(x,D) / p(D)</script> of variables <script type="math/tex">x</script> given observed data <script type="math/tex">D</script> that plays the role of evidence. We assume that <script type="math/tex">p(x,D)</script> is directed. In this case, minimizing <script type="math/tex">J(q)</script> amounts to maximizing a lower bound on the log-likelihood <script type="math/tex">\log p(D)</script> of the observed data.</p>

<p>Because of this property, <script type="math/tex">-J(q)</script> is called the variational lower bound or the evidence lower bound (ELBO); it often written in the form</p>

<script type="math/tex; mode=display">\log Z(\theta) \geq \E_{q(x)} [ \log \tp(x) - \log q(x) ].</script>

<p>Crucially, the difference between <script type="math/tex">\log Z(\theta)</script> and <script type="math/tex">-J(q)</script> is precisely <script type="math/tex">KL(q\|p)</script>. Thus, by maximizing the evidence-lower bound, we are minimizing <script type="math/tex">KL(q\|p)</script> by “squeezing” it between <script type="math/tex">-J(q)</script> and <script type="math/tex">\log Z(\theta)</script>.</p>

<h2 id="on-the-choice-of-kl-divergence">On the choice of KL divergence</h2>

<p>To recap, we have just defined an optimization objective for variational inference (the variational lower bound) and we have shown that maximizing the lower bound leads to minimizing the divergence <script type="math/tex">KL(q\|p)</script>.</p>

<p>Recall how we said earlier that <script type="math/tex">KL(q\|p) \neq KL(p\|q)</script>; both divergences equal zero when <script type="math/tex">q = p</script>, but assign different penalties when <script type="math/tex">q \neq p</script>. This raises the question: why did we choose one over the other and how do they differ?</p>

<p>Perhaps the most important difference is computational: optimizing <script type="math/tex">KL(q\|p)</script> involves an expectation with respect to <script type="math/tex">q</script>, while <script type="math/tex">KL(p\|q)</script> requires computing expectations with respect to <script type="math/tex">p</script>, which is typically intractable even to evaluate.</p>

<p>However, choosing this particular divergence affects the returned solution when the approximating family <script type="math/tex">\mathcal{Q}</script> does not contain the true <script type="math/tex">p</script>. Observe that <script type="math/tex">KL(q\|p)</script> — which is called the I-projection or information projection — is infinite if <script type="math/tex">p(x) = 0</script> and <script type="math/tex">q(x) > 0</script>:</p>

<script type="math/tex; mode=display">KL(q\|p) = \sum_x q(x) \log \frac{q(x)}{p(x)}.</script>

<p>This means that if <script type="math/tex">p(x) = 0</script> we must have <script type="math/tex">q(x) = 0</script>. We say that <script type="math/tex">KL(q\|p)</script> is zero-forcing for <script type="math/tex">q</script> and it will typically under-estimate the support of <script type="math/tex">q</script>.</p>

<p>On the other hand, <script type="math/tex">KL(p\|q)</script> — known as the M-projection or the moment projection — is infinite if <script type="math/tex">q(x) = 0</script> and <script type="math/tex">p(x) > 0</script>. Thus, if <script type="math/tex">p(x) > 0</script> we must have <script type="math/tex">q(x) > 0</script>. We say that <script type="math/tex">KL(p\|q)</script> is zero-avoiding for <script type="math/tex">q</script> and it will typically over-estimate the support of <script type="math/tex">q</script>.</p>

<p>The figure below illustrates this phenomenon graphically.</p>

<figure class="maincolumn">
    <figcaption class="marginnote">Fitting a unimodal approximating distribution q (red) to a multimodal p (blue). Using KL(p||q) leads to a q that tries to cover both modes (a). However, using KL(q||p) forces q to choose one of the two modes of p (b, c).</figcaption><img src="/cs228-notes/assets/img/kldiv.png" alt="Fitting a unimodal approximating distribution q (red) to a multimodal p (blue). Using KL(p||q) leads to a q that tries to cover both modes (a). However, using KL(q||p) forces q to choose one of the two modes of p (b, c)." /></figure>

<p>Due to the properties that we just described, we often call <script type="math/tex">KL(p\|q)</script> the <em>inclusive</em> KL divergence, while <script type="math/tex">KL(q\|p)</script> is the <em>exclusive</em> KL divergence.</p>

<h2 id="mean-field-inference">Mean-field inference</h2>

<p>The next step in our development of variational inference concerns the choice of approximating family <script type="math/tex">\mathcal{Q}</script>. The machine learning literature contains dozens of proposed ways to parametrize this class of distributions; these include exponential families, neural networks, Gaussian processes, latent variable models, and many others types of models.</p>

<p>However, one of the most widely used classes of distributions is simply the set of fully-factored <script type="math/tex">q(x) = q_1(x_1) q_2(x_2) \cdots q_n(x_n)</script>; here each <script type="math/tex">q_i(x_i)</script> is categorical distribution over a one-dimensional discrete variable, which can be described as a one-dimensional table.</p>

<p>This choice of <script type="math/tex">\mathcal{Q}</script> turns out to be easy to optimize over and works surprisingly well. It is perhaps the most popular choice when optimizing the variational bound; variational inference with this choice of <script type="math/tex">\mathcal{Q}</script> is called <em>mean-field</em> inference. It consists in solving the following optimization problem:</p>

<script type="math/tex; mode=display">\min_{q_1, \ldots, q_n} J(q).</script>

<p>The standard way of performing this optimization problem is via coordinate descent over the <script type="math/tex">q_j</script>: we iterate over <script type="math/tex">j=1,2,\ldots,n</script> and for each <script type="math/tex">j</script> we optimize <script type="math/tex">KL(q\|p)</script> over <script type="math/tex">q_j</script> while keeping the other “coordinates” <script type="math/tex">q_{-j} = \prod_{i \neq j} q_i</script> fixed.</p>

<p>Interestingly, the optimization problem for one coordinate has a simple closed form solution:</p>

<script type="math/tex; mode=display">\log q_j(x_j) \gets \E_{q_{-j}} \left[ \log \tp(x) \right] + \textrm{const.}</script>

<p>Notice that both sides of the above equation contain univariate functions of <script type="math/tex">x_j</script>: we are thus replacing <script type="math/tex">q(x_j)</script> with another function of the same form. The constant term is a normalization constant for the new distribution.</p>

<p>Notice also that on right-hand side, we are taking an expectation of a sum of factors</p>

<script type="math/tex; mode=display">\log \tp(x) = \sum_k \log \phi(x_k)</script>

<p>Of these, only factors belonging to the Markov blanket of <script type="math/tex">x_j</script> are a function of <script type="math/tex">x_j</script> (simply by the definition of the Markov blanket); the rest are constant with respect to <script type="math/tex">x_j</script> and can be pushed into the constant term.</p>

<p>This leaves us with an expectation over a much smaller number of factors; if the Markov blanket of <script type="math/tex">x_j</script> is small (as is often the case), we are able to analytically compute <script type="math/tex">q(x_j)</script>. For example, if the variables are discrete with <script type="math/tex">K</script> possible values, and there are <script type="math/tex">F</script> factors and <script type="math/tex">N</script> variables in the Markov blanket of <script type="math/tex">x_j</script>, then computing the expectation takes <script type="math/tex">O(K F K^N)</script> time: for each value of <script type="math/tex">x_j</script> we sum over all <script type="math/tex">K^N</script> assignments of the <script type="math/tex">N</script> variables, and in each case, we sum over the <script type="math/tex">F</script> factors.</p>

<p>The result of this is a procedure that iteratively fits a fully-factored <script type="math/tex">q(x) = q_1(x_1) q_2(x_2) \cdots q_n(x_n)</script> that approximates <script type="math/tex">p</script> in terms of <script type="math/tex">KL(q\|p)</script>. After each step of coordinate descent, we increase the variational lower bound, tightening it around <script type="math/tex">\log Z(\theta)</script>.</p>

<p>In the end, the factors <script type="math/tex">q_j(x_j)</script> will not quite equal the true marginal distributions <script type="math/tex">p(x_j)</script>, but they will often be good enough for many practical purposes, such as determining <script type="math/tex">\max_{x_j} p(x_j)</script>.</p>

<!---
The notes below are incomplete and under construction
## The marginal polytope

A natural question to ask, given what we've seen, is how exactly do the mean-field marginals approximate $$p(x)$$, and what makes them "good enough".

To answer this question, we will take a step back, and define a more general framework for thinking about variational inference. We will then see how mean field and, interestingly, loopy belief propagation (LBP) both fall into this framework and how exactly their approximations differ. As a result, we will also see how LBP is also a form of variational inference, something we have alluded to earlier.

First, recall that we have assumed that the distribution $$p$$ is of the form
$$
p(x_1,\ldots,x_n; \theta) = \frac{\tp(x_1,\ldots,x_n ; \theta)}{Z(\theta)} =\frac{1}{Z(\theta)} \prod_{k} \phi_k(x_k; \theta).
$$
When the variables are discrete, we can further rewrite this as
$$
p(x_1,\ldots,x_n; \theta) = \frac{\exp(\sum_k \theta^T \psi(x))}{Z(\theta)},
$$
where $$\theta_{k, x_k} = \phi_k(x_k)$$ is now a vector of factor values (one for each variable assignment), and $$\psi_{k, x_k}(x') = \mathbb{I(x'_k = x_k)}($$ is a vector of indicator values for each assignment, given an input $$x'$$. The vector $$\psi_k$$ simply "picks out" the appropriate entries of $$\theta$$.

Given this notation, we can write our objective as
$$
\begin{align*}
-J(x)
& = \E_{q(x)} \left[ \theta^T \psi(x) - \log q(x) \right] \\
& = \theta^T \mu - H(\mu),
\end{align*}
$$
where $$H(\mu) = \E_{q(x)} \log q(x)$$ denotes the entropy of $$q(x)$$ and $$\mu = \E_{q(x)} \psi(x)$$ is called the vector of moments. The key observation here is that instead of optimizing over $$q$$, we can equivalently optimize over the set of *valid moments* $$\mu$$.

But which moments are valid? These are the ones that correspond to some probability distribution, i.e. they are in the set
$$
\mathbb{M} = \{ \mu : \exists p \text{ s.t. } \mu = \sum_x \psi(x)p(x) \text{ for some $p(x) \geq 0$ that sums to 1} \}
$$

Notice that $$\mathbb{M}$$ is the intersection of a set of linear constraints: hence it forms a convex set, that we will refer to as the *marginal polytope*. We can thus write the variational inference problem as
$$
\max_\mu \theta^T \mu - H(\mu) \text{ subject to } \mu \in \mathbb{M}.
$$

However, this by itself is not very useful. Although \mathbb{M} is convex, it is hard to describe in general (it is formed by the intersection of an exponential number of hyper-planes). Furthermore, $$H(\mu)$$ may be difficult to compute in general.

We will make this problem feasible by replacing

-->

<p><br /></p>

<table>
  <tbody>
    <tr>
      <td><a href="../../">Index</a></td>
      <td><a href="../sampling">Previous</a></td>
      <td><a href="../../learning/directed">Next</a></td>
    </tr>
  </tbody>
</table>
:ET